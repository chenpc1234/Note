# 数据结构

## 分类

​		数据结构分为 线性结构和非线性结构

- 线性结构
  - 元素之间存在一对一的关系
  - 顺序存储结构(数组)，链式存储结构(链表)
    - 顺序存储结构内存地址是连续的，链式不一定(存放的是数据及相邻节点的地址信息)
  - 数组、队列、链表、栈
- 非线性结构
  - 二维数组、多维数组、广义表、树结构、图结构

# 线性结构

## 队列

- 队列是一个**有序列表**，可以用**数组**或是**链表**来实现。 
- 遵循**先入先出**的原则。即：FIFO先存入队列的数据，要先取出。

### 数组模拟队列

图示：

![image-20220321174430901](数据结构.assets/image-20220321174430901.png)

![image-20220321174531274](数据结构.assets/image-20220321174531274.png)

- **长度为N的数组只能保存N-1个数据**
  - 因为**头尾不能指向同一个数组下标**（队列初始化时除外），尾针对应的数组下标中数据为无效数据
  - 头尾指向通一个数组下标时,不能确定是空队列，还是 45678123 ，如下图

![image-20220321174943185](数据结构.assets/image-20220321174943185.png)



- 使用**对数组长度取模**，实现指针到数组下标尾处重新回到数组下标起始位置

代码设计实现：

```java
 /**
     * 环形数组模拟队列
     * 尾针和头针不能指向数组同一下标，保证环形数组有方向。尾针节点的数据为无效数据
     * 添加数据时，尾针处添加数据，同时尾针后移
     */
    static class ArrayQueue {
        private int maxSize; //队列容量
        private int front; // 队列头针
        private int rear;   //队列尾针
        private int[] data; //数组存放数据

        // 有参构造器
        public ArrayQueue(int size) {
            maxSize = size + 1;
            data = new int[maxSize];
            front = 0;
            rear = 0;
        }

        //判断队列是否满了
        public boolean isFull() {
            return (rear + 1) % maxSize == front;
        }

        //判断队列是否为空
        public boolean isEmpty() {
            return front == rear; //队列头指针 = 队列尾指针
        }

        //添加数据
        public void add(int value) {
            if (isFull()) {
                throw new RuntimeException("队列满了");
            }
            data[rear] = value;
            rear = (rear + 1) % maxSize;
        }

        //获取并移除队列头数据
        public int remove() {
            if (isEmpty()) {
                throw new RuntimeException("队列为空");
            }
            int temp = data[front];
            front = (front + 1) % maxSize;
            return temp;
        }

        //获取队列头数据
        public int element() {
            if (isEmpty()) {
                throw new RuntimeException("队列为空");
            }
            return data[front];
        }

        //获取队列长度
        public int size() {
//            if (front <= rear){
//                return rear-front;
//            }else{
//                return rear+maxSize-front;
//            }
            return (rear + maxSize - front) % maxSize;
        }

        //展示队列数据
        public void showQueue() {
            if (isEmpty()) {
                throw new RuntimeException("队列为空");
            }
            if (front < rear) {
                for (int i = front; i < rear; i++) {
                    System.out.print(data[i] + "\t");
                }
            } else {
                for (int i = front; i < maxSize; i++) {
                    System.out.print(data[i] + "\t");
                }
                for (int i = 0; i < rear; i++) {
                    System.out.print(data[i] + "\t");
                }
            }
        }

    }
```



## 链表

### 单链表

**示意图**

![image-20220322162738359](数据结构.assets/image-20220322162738359.png)

**特点**

- 链表以节点的形式来存储，是**链式存储**
- 单链表每个节点含有**data域和next域**
- 链表的节点在**内存中的分布不一定是连续**的

**代码设计**

[单链表demo]: https://github.com/chenpc1234/Note/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Code/src/main/java/LinkedList/SingleLinkedListDemo.java

**常见面试题**

1. 求单链表中有效节点的个数

   ```java
   public int length(){
       int length =0;
       Node temp = head;
       while(temp.next!=null){
           length++;
           temp=temp.next;
       }
       return length;
   }
   ```

2. 查找单链表中倒数第K个节点

   ```java
   public Node find(int num){
       int length =length();
       if(num > length){
           return null;
       }
       Node temp = head;
       while(temp.next!=null){
           if(length == num ){
   			return temp;
           }
           length--;
           temp=temp.next;
       }
   }
   ```

3. 反转单链表

   ```tex
   1. 定义一个新的头结点
   2. 遍历链表，依次取出当前节点，将当前节点插入新头结点之后
   	2.1 当前节点的尾指针=新头结点的尾指针（当前节点的指针指向了新头结点尾指针指向的节点） temp.next=newHead.next
   	2.2 头节点的尾指针指向当前节点  newHead.next=temp
   	2.3 链表节点后推 
   3.将老头结点的尾指针指向新节点的尾指针 head.next=newHead.next
   ```

4. 逆序打印单链表

   ```tex
   1.不破原有的链表结构
   2.使用Stack栈的先进后出原则。遍历链表依次推送至栈中
   3.打印栈中信息
   ```

5. 合并两个有序的单链表

   ```tex
   1. 定义一个新的链表
   2. 定义两个临时节点遍历temp1 temp2 分别用来遍历两个链表
   3. 循环处理
   	3.1	若temp1节点为空（链表1遍历完成），则直接将temp2节点插入新链表，temp2有next指针，即链表2未遍历的全部插入新链表
   	3.2 若temp2节点为空（链表1遍历完成），则直接将temp1节点插入新链表，temp1有next指针，即链表2未遍历的全部插入新链表
   	3.3 若temp1节点序号比temp2小 则temp1加入新链表  temp1后移
       3.4 若temp2节点序号比temp1小 则temp2加入新链表  temp1后移
       3.5 注：3.3/3.4不能将temp1/temp2直接插入链表，因为有 next指针,可以使用新对象拷贝data域插入
   4. 新链表就是合并的链表
   ```

### 双向链表

**示意图**

![image-20220323155009659](数据结构.assets/image-20220323155009659.png)

**特点**

- 双向链表每个节点含有data数据域和pre和next
  - pre指针指向前一个节点，next指针指向后一个节点
- 双向链表可以向前查找，也可以向后查找
- 单向链表不能自我删除，只能通过修改前一节点的next指向后一节点来完成
  - 单向链表删除时，需要修改 `node.pre.next` 和`node.next.pre`

**代码分析**

[双向链表]: https://github.com/chenpc1234/Note/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Code/src/main/java/LinkedList/DoubleLinkedListDemo.java

### 单向环形链表

**示意图**

![image-20220324142836620](数据结构.assets/image-20220324142836620.png)

**特点**

- 特殊的单向链表，最后一个节点的next指向第一个节点

**约瑟夫问题**

N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。

例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3。

```tex
1. 链表中仅一个节点时 first.next =first
2. 构建一个长度为N的单向循环链表,节点内数据一次+1
3. 遍历单向循环链表
	3.1.从first节点开始计数， 当node.data%M==0 时，说明此节点应该删除 
			即计数到(node.data+1)%M==0 说明下一个节点应该删除，node.next=node.next.next;
	3.2 当node.next =node时 说明只剩下了一个节点。
```

**代码示例**

[约瑟夫问题]: https://github.com/chenpc1234/Note/tree/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Code/src/main/java/LinkedList/Josephus.java

## 栈

### **示意图**

**入栈**

<img src="数据结构.assets/image-20220324151354008.png" alt="image-20220324151354008" style="zoom:80%;" />

**出栈**

<img src="数据结构.assets/image-20220324151428068.png" alt="image-20220324151428068" style="zoom:80%;" />

- 栈遵循FILO原则，先入后出
- 栈限制只能在一端进行插入或者删除操作，称为栈顶（Top） 另外一端称为栈底(Bottom)

### **数组模拟栈**

```tex
1. 数组创建时固定长度，因此创建栈的时候需要给一个长度即maxSize
2. 使用
        struct{
            int maxSize; //记录栈的最大保存记录
            int top = -1 ;	//记录指针，用来表示栈顶,初始化为-1
            Object[] data; //使用数组存储数据
        }
3. 	push ,添加元素时,top++并将元素保存到 data[top] 
	pop 弹出栈顶元素时，返回data[top]并 top--
	peek 查看栈顶元素时，返回data[top]
```

[数组模拟栈]: https://github.com/chenpc1234/Note/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Code/src/main/java/Stack/ArrayStackDemo.java

### **队列模拟栈**

```tex
1. 使用带头和尾的双向队列模拟栈
2. 队列头尾不保存数据,初始化队列时  first.next =last; last.pre=first;
3. 插入,获取都可以使用last来进行
```

[队列模拟栈]: https://github.com/chenpc1234/Note/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Code/src/main/java/Stack/LinkedListStackDemo.java

### **栈实现简单计算器**

 ```java
1. 给定一个计算表达式 如：7+5*15+561/11-6
2. 定义一个计数器 i 
3. while循环处理.判读字符 charAt(i)是不是运算符
    3.1 若是运算符
    	3.1.1截取 0-i 则是数字,将数字加入数字栈
        3.1.2(运算符栈是空栈||符号的优先级大于栈顶符号的优先级)，当前运算符加入运算栈。
         若小于等于运算符栈顶的优先级，将数字栈顶两个数 使用符号栈顶符号进行运算（注意数字栈数的前后顺序）。将运算后的结果加入数			字栈，当前运算符加入符号栈
        3.1.3 截取字符串srt =str.substring(i+1, str.length())，重置计数器 i=0;
    3.2 若是数字符 i++ ,若i= str.length 则遍历完成
4. 遍历符号栈，将数字栈剩余的数字进行计算，数字栈最后的数字就是结果
 ```

[简单计算器]: https://github.com/chenpc1234/Note/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Code/src/main/java/Stack/Calculator.java

### **逆波兰计算器**

- **后缀表达式的计算**

  1. 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；
  2. 重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

- **中缀表达式转后缀表达式**

  1. 初始化两个栈：运算符栈s1和储存中间结果的栈s2；
  2. 从左至右扫描中缀表达式；
     1. 遇到操作数时，将其压s2；
     2. 遇到运算符时，比较其与s1栈顶运算符的优先级：
        1. 如果s1为空，或栈顶运算符为左括号“(”，或优先级比栈顶运算符的高，也将运算符压入s1；
        2. 否则 ，将s1栈顶的运算符弹出并压入到s2中；然后此继续与s1中新的栈顶运算符相比较；
     3. 遇到括号时：
        1. 如果是左括号“(”，则直接压入s1
        2. 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
  3. 重复直到表达式的最右边, 
  4. 将s1中剩余的运算符依次弹出并压入s2
  5. 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

- 代码示例

  [ni]: https://github.com/chenpc1234/Note/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Code/src/main/java/Stack/ReversePolishCalcDemo.java

# 非线性结构

## 稀疏数组

**简介**

​		当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组

稀疏数组的处理方法是: 

1.  记录数组**一共有几行几列，有多少个不同**的值 
2. 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而**缩小程序**的规模

**实际应用**

棋盘：比如一个11*11的棋盘，第2行第3列有一个白棋，第3行第4列以及第5行第6列有一个黑棋

- 二维数组

  ```java
  int[][] chessArr = new int[11][11]; //使用11*11 数组模拟棋盘
  chessArr[1][2] = 1;   //记录下标  1表示白棋
  chessArr[2][3] = 2;
  chessArr1[4][5] = 2; //记录下标  2表示黑棋 
  ```

- 稀疏数组

  ```java
  int[][] sparseArr ={{11,11,3},
                      {1,2,1}
                      {2,3,2}
                      {4,5,2}
                     };
  //1. 不记录空白位置
  //2. 首行记录棋盘大小 长,宽，棋子数(白+黑)
  //3. 从前往后记录每个棋子的坐标
  ```

  

# 算法

## 递归算法



## 时间复杂度

# 排序

## 冒泡排序

## 选择排序

## 插入排序

## 希尔排序

## 快速排序

## 归并排序

## 基数排序

# 查找