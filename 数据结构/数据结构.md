# 数据结构

## 分类

​		数据结构分为 线性结构和非线性结构

- 线性结构
  - 元素之间存在一对一的关系
  - 顺序存储结构(数组)，链式存储结构(链表)
    - 顺序存储结构内存地址是连续的，链式不一定(存放的是数据及相邻节点的地址信息)
  - 数组、队列、链表、栈
- 非线性结构
  - 二维数组、多维数组、广义表、树结构、图结构

# 线性结构

## 队列

- 队列是一个**有序列表**，可以用**数组**或是**链表**来实现。 
- 遵循**先入先出**的原则。即：FIFO先存入队列的数据，要先取出。

### 数组模拟队列

图示：

![image-20220321174430901](数据结构.assets/image-20220321174430901.png)

![image-20220321174531274](数据结构.assets/image-20220321174531274.png)

- **长度为N的数组只能保存N-1个数据**
  - 因为**头尾不能指向同一个数组下标**（队列初始化时除外），尾针对应的数组下标中数据为无效数据
  - 头尾指向通一个数组下标时,不能确定是空队列，还是 45678123 ，如下图

![image-20220321174943185](数据结构.assets/image-20220321174943185.png)



- 使用**对数组长度取模**，实现指针到数组下标尾处重新回到数组下标起始位置

代码设计实现：

```java
 /**
     * 环形数组模拟队列
     * 尾针和头针不能指向数组同一下标，保证环形数组有方向。尾针节点的数据为无效数据
     * 添加数据时，尾针处添加数据，同时尾针后移
     */
    static class ArrayQueue {
        private int maxSize; //队列容量
        private int front; // 队列头针
        private int rear;   //队列尾针
        private int[] data; //数组存放数据

        // 有参构造器
        public ArrayQueue(int size) {
            maxSize = size + 1;
            data = new int[maxSize];
            front = 0;
            rear = 0;
        }

        //判断队列是否满了
        public boolean isFull() {
            return (rear + 1) % maxSize == front;
        }

        //判断队列是否为空
        public boolean isEmpty() {
            return front == rear; //队列头指针 = 队列尾指针
        }

        //添加数据
        public void add(int value) {
            if (isFull()) {
                throw new RuntimeException("队列满了");
            }
            data[rear] = value;
            rear = (rear + 1) % maxSize;
        }

        //获取并移除队列头数据
        public int remove() {
            if (isEmpty()) {
                throw new RuntimeException("队列为空");
            }
            int temp = data[front];
            front = (front + 1) % maxSize;
            return temp;
        }

        //获取队列头数据
        public int element() {
            if (isEmpty()) {
                throw new RuntimeException("队列为空");
            }
            return data[front];
        }

        //获取队列长度
        public int size() {
//            if (front <= rear){
//                return rear-front;
//            }else{
//                return rear+maxSize-front;
//            }
            return (rear + maxSize - front) % maxSize;
        }

        //展示队列数据
        public void showQueue() {
            if (isEmpty()) {
                throw new RuntimeException("队列为空");
            }
            if (front < rear) {
                for (int i = front; i < rear; i++) {
                    System.out.print(data[i] + "\t");
                }
            } else {
                for (int i = front; i < maxSize; i++) {
                    System.out.print(data[i] + "\t");
                }
                for (int i = 0; i < rear; i++) {
                    System.out.print(data[i] + "\t");
                }
            }
        }

    }
```



## 链表

### 单链表

![image-20220322162738359](数据结构.assets/image-20220322162738359.png)

- 链表以节点的形式来存储，是**链式存储**
- 单链表每个节点含有**data域和next域**
- 链表的节点在**内存中的分布不一定是连续**的

**代码设计**

[单链表demo]: https://github.com/chenpc1234/Note/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Code/src/main/java/LinkedList/SingleLinkedListDemo.java

**常见面试题**

1. 求单链表中有效节点的个数

   ```java
   public int length(){
       int length =0;
       Node temp = head;
       while(temp.next!=null){
           length++;
           temp=temp.next;
       }
       return length;
   }
   ```

2. 查找单链表中倒数第K个节点

   ```java
   public Node find(int num){
       int length =length();
       if(num > length){
           return null;
       }
       Node temp = head;
       while(temp.next!=null){
           if(length == num ){
   			return temp;
           }
           length--;
           temp=temp.next;
       }
   }
   ```

3. 反转单链表

   ```tex
   1. 定义一个新的头结点
   2. 遍历链表，依次取出当前节点，将当前节点插入新头结点之后
   	2.1 当前节点的尾指针=新头结点的尾指针（当前节点的指针指向了新头结点尾指针指向的节点） temp.next=newHead.next
   	2.2 头节点的尾指针指向当前节点  newHead.next=temp
   	2.3 链表节点后推 
   3.将老头结点的尾指针指向新节点的尾指针 head.next=newHead.next
   ```

4. 逆序打印单链表

   ```tex
   1.不破原有的链表结构
   2.使用Stack栈的先进后出原则。遍历链表依次推送至栈中
   3.打印栈中信息
   ```

5. 合并两个有序的单链表

   ```tex
   1. 定义一个新的链表
   2. 定义两个临时节点遍历temp1 temp2 分别用来遍历两个链表
   3. 循环处理
   	3.1	若temp1节点为空（链表1遍历完成），则直接将temp2节点插入新链表，temp2有next指针，即链表2未遍历的全部插入新链表
   	3.2 若temp2节点为空（链表1遍历完成），则直接将temp1节点插入新链表，temp1有next指针，即链表2未遍历的全部插入新链表
   	3.3 若temp1节点序号比temp2小 则temp1加入新链表  temp1后移
       3.4 若temp2节点序号比temp1小 则temp2加入新链表  temp1后移
       3.5 注：3.3/3.4不能将temp1/temp2直接插入链表，因为有 next指针,可以使用新对象拷贝data域插入
   4. 新链表就是合并的链表
   ```

### 双向链表

![image-20220323155009659](数据结构.assets/image-20220323155009659.png)

- 双向链表每个节点含有data数据域和pre和next
  - pre指针指向前一个节点 next指针指向后一个节点
- 双向链表可以向前查找，也可以向后查找
- 单向链表不能自我删除，只能通过修改前一节点的next指向后一节点来完成

### 单向环形链表

# 非线性结构

## 稀疏数组

**简介**

​		当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组

稀疏数组的处理方法是: 

1.  记录数组**一共有几行几列，有多少个不同**的值 
2. 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而**缩小程序**的规模

**实际应用**

棋盘：比如一个11*11的棋盘，第2行第3列有一个白棋，第3行第4列以及第5行第6列有一个黑棋

- 二维数组

  ```java
  int[][] chessArr = new int[11][11]; //使用11*11 数组模拟棋盘
  chessArr[1][2] = 1;   //记录下标  1表示白棋
  chessArr[2][3] = 2;
  chessArr1[4][5] = 2; //记录下标  2表示黑棋 
  ```

- 稀疏数组

  ```java
  int[][] sparseArr ={{11,11,3},
                      {1,2,1}
                      {2,3,2}
                      {4,5,2}
                     };
  //1. 不记录空白位置
  //2. 首行记录棋盘大小 长,宽，棋子数(白+黑)
  //3. 从前往后记录每个棋子的坐标
  ```

  